

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-164358105-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-164358105-1');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mhkit.wave.contours &mdash; MHKiT v0.9.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=5b801204" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=5ea31d45" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/mhkit.css?v=20290a2c" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=c20ff342"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            MHKiT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">MHKiT-Python Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../matlab_installation.html">MHKiT-MATLAB Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module.html">Module Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../terminology.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../webinars.html">Webinars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../citeus.html">Cite Us</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Online Forum</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MHKiT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mhkit.wave.contours</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mhkit.wave.contours</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.nonparametric.kde</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDEUnivariate</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span> <span class="k">as</span> <span class="n">skPCA</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">optim</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">stats</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">interp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mhkit.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">to_numeric_array</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span>


<span class="c1"># Contours</span>
<div class="viewcode-block" id="environmental_contours">
<a class="viewcode-back" href="../../../mhkit-python/api.wave.html#mhkit.wave.contours.environmental_contours">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">environmental_contours</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">sea_state_duration</span><span class="p">,</span> <span class="n">return_period</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a Dictionary of x1 and x2 components for each contour</span>
<span class="sd">    method passed. A method  may be one of the following:</span>
<span class="sd">    Principal Component Analysis, Gaussian, Gumbel, Clayton, Rosenblatt,</span>
<span class="sd">    nonparametric Gaussian, nonparametric Clayton,</span>
<span class="sd">    nonparametric Gumbel, bivariate KDE, log bivariate KDE</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: list, np.ndarray, pd.Series, xr.DataArray</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: list, np.ndarray, pd.Series, xr.DataArray</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    sea_state_duration : int or float</span>
<span class="sd">        `x1` and `x2` averaging period in seconds</span>
<span class="sd">    return_period: int, float</span>
<span class="sd">        Return period of interest in years</span>
<span class="sd">    method: string or list</span>
<span class="sd">        Copula method to apply. Options include [&#39;PCA&#39;,&#39;gaussian&#39;,</span>
<span class="sd">        &#39;gumbel&#39;, &#39;clayton&#39;, &#39;rosenblatt&#39;, &#39;nonparametric_gaussian&#39;,</span>
<span class="sd">        &#39;nonparametric_clayton&#39;, &#39;nonparametric_gumbel&#39;, &#39;bivariate_KDE&#39;</span>
<span class="sd">        &#39;bivariate_KDE_log&#39;]</span>

<span class="sd">    **kwargs</span>
<span class="sd">        min_bin_count: int</span>
<span class="sd">            Passed to _copula_parameters to sets the minimum number of</span>
<span class="sd">            bins allowed. Default = 40.</span>
<span class="sd">        initial_bin_max_val: int, float</span>
<span class="sd">            Passed to _copula_parameters to set the max value of the</span>
<span class="sd">            first bin. Default = 1.</span>
<span class="sd">        bin_val_size: int, float</span>
<span class="sd">            Passed to _copula_parameters to set the size of each bin</span>
<span class="sd">            after the initial bin.  Default 0.25.</span>
<span class="sd">        nb_steps: int</span>
<span class="sd">            Discretization of the circle in the normal space is used for</span>
<span class="sd">            copula component calculation. Default nb_steps=1000.</span>
<span class="sd">        bandwidth:</span>
<span class="sd">            Must specify bandwidth for bivariate KDE method.</span>
<span class="sd">            Default = None.</span>
<span class="sd">        Ndata_bivariate_KDE: int</span>
<span class="sd">            Must specify bivariate KDE method. Defines the contoured</span>
<span class="sd">            space from which samples are taken. Default = 100.</span>
<span class="sd">        max_x1: float</span>
<span class="sd">            Defines the max value of x1 to discretize the KDE space</span>
<span class="sd">        max_x2: float</span>
<span class="sd">            Defines the max value of x2 to discretize the KDE space</span>
<span class="sd">        PCA: dict</span>
<span class="sd">            If provided, the principal component analysis (PCA) on x1,</span>
<span class="sd">            x2 is skipped. The PCA will be the same for a given x1, x2</span>
<span class="sd">            therefore this step may be skipped if multiple calls to</span>
<span class="sd">            environmental contours are made for the same x1, x2 pair.</span>
<span class="sd">            The PCA dict may be obtained by setting return_fit=True when</span>
<span class="sd">            calling the PCA method.</span>
<span class="sd">        return_fit: boolean</span>
<span class="sd">            Will return fitting parameters used for each method passed.</span>
<span class="sd">            Default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    copulas: Dictionary</span>
<span class="sd">        Dictionary of x1 and x2 copula components for each copula method</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="s2">&quot;x1&quot;</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="s2">&quot;x2&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be a non-scalar array. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be a non-scalar array. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The lengths of x1 and x2 must be equal.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sea_state_duration</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;sea_state_duration must be of type int or float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sea_state_duration</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_period</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;return_period must be of type int, float, or np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_period</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">bin_val_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bin_val_size&quot;</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
    <span class="n">nb_steps</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nb_steps&quot;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">initial_bin_max_val</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;initial_bin_max_val&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">min_bin_count</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;min_bin_count&quot;</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
    <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bandwidth&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">Ndata_bivariate_KDE</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Ndata_bivariate_KDE&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">max_x1</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_x1&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">max_x2</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_x2&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">PCA</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;PCA&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">PCA_bin_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;PCA_bin_size&quot;</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
    <span class="n">return_fit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_fit&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_x1</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;If specified, max_x1 must be a dict. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">PCA</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_x2</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;If specified, max_x2 must be a dict. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">PCA</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">PCA</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;If specified, PCA must be a dict. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">PCA</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">PCA_bin_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PCA_bin_size must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">PCA_bin_size</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_fit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return_fit must be of type bool. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_fit</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_val_size</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;bin_val_size must be of type int or float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">bin_val_size</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nb_steps must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_bin_count</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;min_bin_count must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">min_bin_count</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_bin_max_val</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;initial_bin_max_val must be of type int or float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">initial_bin_max_val</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;bivariate_KDE&quot;</span> <span class="ow">in</span> <span class="n">method</span> <span class="ow">and</span> <span class="n">bandwidth</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Must specify keyword bandwidth with bivariate KDE method. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">method</span> <span class="o">=</span> <span class="p">[</span><span class="n">method</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">method</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">method</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Can only pass a unique &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;method once per function call. Consider wrapping this &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;function in a for loop to investage variations on the same method&quot;</span>
        <span class="p">)</span>

    <span class="n">method_class</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;PCA&quot;</span><span class="p">:</span> <span class="s2">&quot;parametric&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span> <span class="s2">&quot;parametric&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gumbel&quot;</span><span class="p">:</span> <span class="s2">&quot;parametric&quot;</span><span class="p">,</span>
        <span class="s2">&quot;clayton&quot;</span><span class="p">:</span> <span class="s2">&quot;parametric&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rosenblatt&quot;</span><span class="p">:</span> <span class="s2">&quot;parametric&quot;</span><span class="p">,</span>
        <span class="s2">&quot;nonparametric_gaussian&quot;</span><span class="p">:</span> <span class="s2">&quot;nonparametric&quot;</span><span class="p">,</span>
        <span class="s2">&quot;nonparametric_clayton&quot;</span><span class="p">:</span> <span class="s2">&quot;nonparametric&quot;</span><span class="p">,</span>
        <span class="s2">&quot;nonparametric_gumbel&quot;</span><span class="p">:</span> <span class="s2">&quot;nonparametric&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bivariate_KDE&quot;</span><span class="p">:</span> <span class="s2">&quot;KDE&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bivariate_KDE_log&quot;</span><span class="p">:</span> <span class="s2">&quot;KDE&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">classification</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">methods</span> <span class="o">=</span> <span class="n">method</span>
    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>
        <span class="n">classification</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">method_class</span><span class="p">[</span><span class="n">method</span><span class="p">])</span>

    <span class="n">fit</span> <span class="o">=</span> <span class="n">_iso_prob_and_quantile</span><span class="p">(</span><span class="n">sea_state_duration</span><span class="p">,</span> <span class="n">return_period</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">)</span>
    <span class="n">fit_parametric</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">fit_nonparametric</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">component_1</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s2">&quot;parametric&quot;</span> <span class="ow">in</span> <span class="n">classification</span><span class="p">:</span>
        <span class="p">(</span><span class="n">para_dist_1</span><span class="p">,</span> <span class="n">para_dist_2</span><span class="p">,</span> <span class="n">mean_cond</span><span class="p">,</span> <span class="n">std_cond</span><span class="p">)</span> <span class="o">=</span> <span class="n">_copula_parameters</span><span class="p">(</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">min_bin_count</span><span class="p">,</span> <span class="n">initial_bin_max_val</span><span class="p">,</span> <span class="n">bin_val_size</span>
        <span class="p">)</span>

        <span class="n">x_quantile</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;x_quantile&quot;</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">para_dist_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">para_dist_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">para_dist_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">para_dist_1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

        <span class="n">component_1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">exponweib</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">x_quantile</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

        <span class="n">fit_parametric</span> <span class="o">=</span> <span class="n">fit</span>
        <span class="n">fit_parametric</span><span class="p">[</span><span class="s2">&quot;para_dist_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">para_dist_1</span>
        <span class="n">fit_parametric</span><span class="p">[</span><span class="s2">&quot;para_dist_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">para_dist_2</span>
        <span class="n">fit_parametric</span><span class="p">[</span><span class="s2">&quot;mean_cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_cond</span>
        <span class="n">fit_parametric</span><span class="p">[</span><span class="s2">&quot;std_cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">std_cond</span>
        <span class="k">if</span> <span class="n">PCA</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">PCA</span> <span class="o">=</span> <span class="n">fit_parametric</span>

    <span class="k">if</span> <span class="s2">&quot;nonparametric&quot;</span> <span class="ow">in</span> <span class="n">classification</span><span class="p">:</span>
        <span class="p">(</span>
            <span class="n">nonpara_dist_1</span><span class="p">,</span>
            <span class="n">nonpara_dist_2</span><span class="p">,</span>
            <span class="n">nonpara_pdf_2</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">_nonparametric_copula_parameters</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">nb_steps</span><span class="o">=</span><span class="n">nb_steps</span><span class="p">)</span>
        <span class="n">fit_nonparametric</span> <span class="o">=</span> <span class="n">fit</span>
        <span class="n">fit_nonparametric</span><span class="p">[</span><span class="s2">&quot;nonpara_dist_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonpara_dist_1</span>
        <span class="n">fit_nonparametric</span><span class="p">[</span><span class="s2">&quot;nonpara_dist_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonpara_dist_2</span>
        <span class="n">fit_nonparametric</span><span class="p">[</span><span class="s2">&quot;nonpara_pdf_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonpara_pdf_2</span>

    <span class="n">copula_functions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;PCA&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">PCA_contour</span><span class="p">,</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">x1</span><span class="p">,</span>
                <span class="n">x2</span><span class="p">,</span>
                <span class="n">PCA</span><span class="p">,</span>
                <span class="p">{</span>
                    <span class="s2">&quot;nb_steps&quot;</span><span class="p">:</span> <span class="n">nb_steps</span><span class="p">,</span>
                    <span class="s2">&quot;return_fit&quot;</span><span class="p">:</span> <span class="n">return_fit</span><span class="p">,</span>
                    <span class="s2">&quot;bin_size&quot;</span><span class="p">:</span> <span class="n">PCA_bin_size</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">),</span>
        <span class="p">},</span>
        <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">_gaussian_copula</span><span class="p">,</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit_parametric</span><span class="p">,</span> <span class="n">component_1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;return_fit&quot;</span><span class="p">:</span> <span class="n">return_fit</span><span class="p">}),</span>
        <span class="p">},</span>
        <span class="s2">&quot;gumbel&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">_gumbel_copula</span><span class="p">,</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">x1</span><span class="p">,</span>
                <span class="n">x2</span><span class="p">,</span>
                <span class="n">fit_parametric</span><span class="p">,</span>
                <span class="n">component_1</span><span class="p">,</span>
                <span class="n">nb_steps</span><span class="p">,</span>
                <span class="p">{</span><span class="s2">&quot;return_fit&quot;</span><span class="p">:</span> <span class="n">return_fit</span><span class="p">},</span>
            <span class="p">),</span>
        <span class="p">},</span>
        <span class="s2">&quot;clayton&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">_clayton_copula</span><span class="p">,</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit_parametric</span><span class="p">,</span> <span class="n">component_1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;return_fit&quot;</span><span class="p">:</span> <span class="n">return_fit</span><span class="p">}),</span>
        <span class="p">},</span>
        <span class="s2">&quot;rosenblatt&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">_rosenblatt_copula</span><span class="p">,</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit_parametric</span><span class="p">,</span> <span class="n">component_1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;return_fit&quot;</span><span class="p">:</span> <span class="n">return_fit</span><span class="p">}),</span>
        <span class="p">},</span>
        <span class="s2">&quot;nonparametric_gaussian&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">_nonparametric_gaussian_copula</span><span class="p">,</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit_nonparametric</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;return_fit&quot;</span><span class="p">:</span> <span class="n">return_fit</span><span class="p">}),</span>
        <span class="p">},</span>
        <span class="s2">&quot;nonparametric_clayton&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">_nonparametric_clayton_copula</span><span class="p">,</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit_nonparametric</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;return_fit&quot;</span><span class="p">:</span> <span class="n">return_fit</span><span class="p">}),</span>
        <span class="p">},</span>
        <span class="s2">&quot;nonparametric_gumbel&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">_nonparametric_gumbel_copula</span><span class="p">,</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit_nonparametric</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;return_fit&quot;</span><span class="p">:</span> <span class="n">return_fit</span><span class="p">}),</span>
        <span class="p">},</span>
        <span class="s2">&quot;bivariate_KDE&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">_bivariate_KDE</span><span class="p">,</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">x1</span><span class="p">,</span>
                <span class="n">x2</span><span class="p">,</span>
                <span class="n">bandwidth</span><span class="p">,</span>
                <span class="n">fit</span><span class="p">,</span>
                <span class="n">nb_steps</span><span class="p">,</span>
                <span class="n">Ndata_bivariate_KDE</span><span class="p">,</span>
                <span class="p">{</span><span class="s2">&quot;max_x1&quot;</span><span class="p">:</span> <span class="n">max_x1</span><span class="p">,</span> <span class="s2">&quot;max_x2&quot;</span><span class="p">:</span> <span class="n">max_x2</span><span class="p">,</span> <span class="s2">&quot;return_fit&quot;</span><span class="p">:</span> <span class="n">return_fit</span><span class="p">},</span>
            <span class="p">),</span>
        <span class="p">},</span>
        <span class="s2">&quot;bivariate_KDE_log&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">_bivariate_KDE</span><span class="p">,</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">x1</span><span class="p">,</span>
                <span class="n">x2</span><span class="p">,</span>
                <span class="n">bandwidth</span><span class="p">,</span>
                <span class="n">fit</span><span class="p">,</span>
                <span class="n">nb_steps</span><span class="p">,</span>
                <span class="n">Ndata_bivariate_KDE</span><span class="p">,</span>
                <span class="p">{</span>
                    <span class="s2">&quot;max_x1&quot;</span><span class="p">:</span> <span class="n">max_x1</span><span class="p">,</span>
                    <span class="s2">&quot;max_x2&quot;</span><span class="p">:</span> <span class="n">max_x2</span><span class="p">,</span>
                    <span class="s2">&quot;log_transform&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="s2">&quot;return_fit&quot;</span><span class="p">:</span> <span class="n">return_fit</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">),</span>
        <span class="p">},</span>
    <span class="p">}</span>
    <span class="n">copulas</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">copula_functions</span><span class="p">[</span><span class="n">method</span><span class="p">][</span><span class="s2">&quot;vals&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_fit</span><span class="p">:</span>
            <span class="n">component_1</span><span class="p">,</span> <span class="n">component_2</span><span class="p">,</span> <span class="n">fit</span> <span class="o">=</span> <span class="n">copula_functions</span><span class="p">[</span><span class="n">method</span><span class="p">][</span><span class="s2">&quot;func&quot;</span><span class="p">](</span><span class="o">*</span><span class="n">vals</span><span class="p">)</span>
            <span class="n">copulas</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">_fit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">component_1</span><span class="p">,</span> <span class="n">component_2</span> <span class="o">=</span> <span class="n">copula_functions</span><span class="p">[</span><span class="n">method</span><span class="p">][</span><span class="s2">&quot;func&quot;</span><span class="p">](</span><span class="o">*</span><span class="n">vals</span><span class="p">)</span>
        <span class="n">copulas</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">_x1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">component_1</span>
        <span class="n">copulas</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">_x2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">component_2</span>

    <span class="k">return</span> <span class="n">copulas</span></div>



<div class="viewcode-block" id="PCA_contour">
<a class="viewcode-back" href="../../../mhkit-python/api.wave.html#mhkit.wave.contours.PCA_contour">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">PCA_contour</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates environmental contours of extreme sea</span>
<span class="sd">    states using the improved joint probability distributions</span>
<span class="sd">    with the inverse first-order reliability method (I-FORM)</span>
<span class="sd">    probability for the desired return period (`return_period`). Given</span>
<span class="sd">    the return_period of interest, a circle of iso-probability is</span>
<span class="sd">    created in the principal component analysis (PCA) joint probability</span>
<span class="sd">    (`x1`, `x2`) reference frame.</span>
<span class="sd">    Using the joint probability value, the cumulative distribution</span>
<span class="sd">    function (CDF) of the marginal distribution is used to find</span>
<span class="sd">    the quantile of each component.</span>
<span class="sd">    Finally, using the improved PCA methodology,</span>
<span class="sd">    the component 2 contour lines are calculated from component 1 using</span>
<span class="sd">    the relationships defined in Eckert-Gallup et. al. 2016.</span>

<span class="sd">    Eckert-Gallup, A. C., Sallaberry, C. J., Dallman, A. R., &amp;</span>
<span class="sd">    Neary, V. S. (2016). Application of principal component</span>
<span class="sd">    analysis (PCA) and improved joint probability distributions to</span>
<span class="sd">    the inverse first-order reliability method (I-FORM) for predicting</span>
<span class="sd">    extreme sea states. Ocean Engineering, 112, 307-319.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: list, np.ndarray, pd.Series, xr.DataArray</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: list, np.ndarray, pd.Series, xr.DataArray</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    fit: dict</span>
<span class="sd">        Dictionary of the iso-probability results. May additionally</span>
<span class="sd">        contain the principal component analysis (PCA) on x1, x2</span>
<span class="sd">        The PCA will be the same for a given x1, x2</span>
<span class="sd">        therefore this step may be skipped if multiple calls to</span>
<span class="sd">        environmental contours are made for the same x1, x2 pair.</span>
<span class="sd">        The PCA dict may be obtained by setting return_fit=True when</span>
<span class="sd">        calling the PCA method.</span>
<span class="sd">    kwargs : optional</span>
<span class="sd">        bin_size : int</span>
<span class="sd">            Data points in each bin for the PCA fit. Default bin_size=250.</span>
<span class="sd">        nb_steps : int</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            I-FORM calculation. Default nb_steps=1000.</span>
<span class="sd">        return_fit: boolean</span>
<span class="sd">            Default False, if True will return the PCA fit dictionary</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x1_contour : numpy array</span>
<span class="sd">        Calculated x1 values along the contour boundary following</span>
<span class="sd">        return to original input orientation.</span>
<span class="sd">    x2_contour : numpy array</span>
<span class="sd">        Calculated x2 values along the contour boundary following</span>
<span class="sd">        return to original input orientation.</span>
<span class="sd">    fit: dict (optional)</span>
<span class="sd">            principal component analysis dictionary</span>
<span class="sd">        Keys:</span>
<span class="sd">        -----</span>
<span class="sd">        &#39;principal_axes&#39;: sign corrected PCA axes</span>
<span class="sd">        &#39;shift&#39;         : The shift applied to x2</span>
<span class="sd">        &#39;x1_fit&#39;        : gaussian fit of x1 data</span>
<span class="sd">        &#39;mu_param&#39;      : fit to _mu_fcn</span>
<span class="sd">        &#39;sigma_param&#39;   : fit to _sig_fits</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="s2">&quot;x1&quot;</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="s2">&quot;x2&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be a non-scalar array. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be a non-scalar array. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The lengths of x1 and x2 must be equal.&quot;</span><span class="p">)</span>

    <span class="n">bin_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bin_size&quot;</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
    <span class="n">nb_steps</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nb_steps&quot;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">return_fit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_fit&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bin_size must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">bin_size</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nb_steps must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_fit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return_fit must be of type bool. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_fit</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;x1_fit&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fit</span><span class="p">:</span>
        <span class="n">pca_fit</span> <span class="o">=</span> <span class="n">_principal_component_analysis</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="n">bin_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">pca_fit</span><span class="p">:</span>
            <span class="n">fit</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pca_fit</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="n">x_quantile</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;x_quantile&quot;</span><span class="p">]</span>
    <span class="n">y_quantile</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;y_quantile&quot;</span><span class="p">]</span>

    <span class="c1"># Use the inverse of cdf to calculate component 1 values</span>
    <span class="n">component_1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span>
        <span class="n">x_quantile</span><span class="p">,</span>
        <span class="n">mu</span><span class="o">=</span><span class="n">fit</span><span class="p">[</span><span class="s2">&quot;x1_fit&quot;</span><span class="p">][</span><span class="s2">&quot;mu&quot;</span><span class="p">],</span>
        <span class="n">loc</span><span class="o">=</span><span class="n">fit</span><span class="p">[</span><span class="s2">&quot;x1_fit&quot;</span><span class="p">][</span><span class="s2">&quot;loc&quot;</span><span class="p">],</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">fit</span><span class="p">[</span><span class="s2">&quot;x1_fit&quot;</span><span class="p">][</span><span class="s2">&quot;scale&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Find Component 2 mu using first order linear regression</span>
    <span class="n">mu_slope</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;mu_fit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">slope</span>
    <span class="n">mu_intercept</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;mu_fit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">intercept</span>
    <span class="n">component_2_mu</span> <span class="o">=</span> <span class="n">mu_slope</span> <span class="o">*</span> <span class="n">component_1</span> <span class="o">+</span> <span class="n">mu_intercept</span>

    <span class="c1"># Find Componenet 2 sigma using second order polynomial fit</span>
    <span class="n">sigma_polynomial_coeffcients</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;sigma_fit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
    <span class="n">component_2_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">sigma_polynomial_coeffcients</span><span class="p">,</span> <span class="n">component_1</span><span class="p">)</span>

    <span class="c1"># Use calculated mu and sigma values to calculate C2 along the contour</span>
    <span class="n">component_2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span>
        <span class="n">y_quantile</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">component_2_mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">component_2_sigma</span>
    <span class="p">)</span>

    <span class="c1"># Convert contours back to the original reference frame</span>
    <span class="n">principal_axes</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;principal_axes&quot;</span><span class="p">]</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;shift&quot;</span><span class="p">]</span>
    <span class="n">pa00</span> <span class="o">=</span> <span class="n">principal_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">pa01</span> <span class="o">=</span> <span class="n">principal_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">x1_contour</span> <span class="o">=</span> <span class="p">(</span><span class="n">pa00</span> <span class="o">*</span> <span class="n">component_1</span> <span class="o">+</span> <span class="n">pa01</span> <span class="o">*</span> <span class="p">(</span><span class="n">component_2</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
        <span class="n">pa01</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pa00</span><span class="o">**</span><span class="mi">2</span>
    <span class="p">)</span>
    <span class="n">x2_contour</span> <span class="o">=</span> <span class="p">(</span><span class="n">pa01</span> <span class="o">*</span> <span class="n">component_1</span> <span class="o">-</span> <span class="n">pa00</span> <span class="o">*</span> <span class="p">(</span><span class="n">component_2</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
        <span class="n">pa01</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pa00</span><span class="o">**</span><span class="mi">2</span>
    <span class="p">)</span>

    <span class="c1"># Assign 0 value to any negative x1 contour values</span>
    <span class="n">x1_contour</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x1_contour</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_fit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x1_contour</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x2_contour</span><span class="p">),</span> <span class="n">fit</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x1_contour</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x2_contour</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_principal_component_analysis</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mi">250</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs a modified principal component analysis (PCA)</span>
<span class="sd">    [Eckert et. al 2016] on two variables (`x1`, `x2`). The additional</span>
<span class="sd">    PCA is performed in 5 steps:</span>
<span class="sd">    1) Transform `x1` &amp; `x2` into the principal component domain and</span>
<span class="sd">       shift the y-axis so that all values are positive and non-zero</span>
<span class="sd">    2) Fit the `x1` data in the transformed reference frame with an</span>
<span class="sd">       inverse Gaussian Distribution</span>
<span class="sd">    3) Bin the transformed data into groups of size bin and find the</span>
<span class="sd">       mean of `x1`, the mean of `x2`, and the standard deviation of</span>
<span class="sd">       `x2`</span>
<span class="sd">    4) Perform a first-order linear regression to determine a continuous</span>
<span class="sd">       the function relating the mean of the `x1` bins to mean of the</span>
<span class="sd">       `x2` bins</span>
<span class="sd">    5) Find a second-order polynomial which best relates the means of</span>
<span class="sd">       `x1` to the standard deviation of `x2` using constrained</span>
<span class="sd">       optimization</span>

<span class="sd">    Eckert-Gallup, A. C., Sallaberry, C. J., Dallman, A. R., &amp;</span>
<span class="sd">    Neary, V. S. (2016). Application of principal component</span>
<span class="sd">    analysis (PCA) and improved joint probability distributions to</span>
<span class="sd">    the inverse first-order reliability method (I-FORM) for predicting</span>
<span class="sd">    extreme sea states. Ocean Engineering, 112, 307-319.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: numpy array</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: numpy array</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    bin_size : int</span>
<span class="sd">        Number of data points in each bin</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    PCA: dict</span>
<span class="sd">       Keys:</span>
<span class="sd">       -----</span>
<span class="sd">       &#39;principal_axes&#39;: sign corrected PCA axes</span>
<span class="sd">       &#39;shift&#39;         : The shift applied to x2</span>
<span class="sd">       &#39;x1_fit&#39;        : gaussian fit of x1 data</span>
<span class="sd">       &#39;mu_param&#39;      : fit to _mu_fcn</span>
<span class="sd">       &#39;sigma_param&#39;   : fit to _sig_fits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bin_size must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">bin_size</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Step 0: Perform Standard PCA</span>
    <span class="n">mean_location</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">x1_mean_centered</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x1</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x2_mean_centered</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x2</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">n_samples_by_n_features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x1_mean_centered</span><span class="p">,</span> <span class="n">x2_mean_centered</span><span class="p">))</span>
    <span class="n">pca</span> <span class="o">=</span> <span class="n">skPCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">n_samples_by_n_features</span><span class="p">)</span>
    <span class="n">principal_axes</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">components_</span>

    <span class="c1"># STEP 1: Transform data into new reference frame</span>
    <span class="c1"># Apply correct/expected sign convention</span>
    <span class="n">principal_axes</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">principal_axes</span><span class="p">)</span>
    <span class="n">principal_axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">principal_axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Rotate data into Principal direction</span>
    <span class="n">x1_and_x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
    <span class="n">x1_x2_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x1_and_x2</span><span class="p">,</span> <span class="n">principal_axes</span><span class="p">)</span>
    <span class="n">x1_components</span> <span class="o">=</span> <span class="n">x1_x2_components</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">x2_components</span> <span class="o">=</span> <span class="n">x1_x2_components</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Apply shift to Component 2 to make all values positive</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x2_components</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.1</span>
    <span class="n">x2_components</span> <span class="o">=</span> <span class="n">x2_components</span> <span class="o">+</span> <span class="n">shift</span>

    <span class="c1"># STEP 2: Fit Component 1 data using a Gaussian Distribution</span>
    <span class="n">x1_sorted_index</span> <span class="o">=</span> <span class="n">x1_components</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">x1_sorted</span> <span class="o">=</span> <span class="n">x1_components</span><span class="p">[</span><span class="n">x1_sorted_index</span><span class="p">]</span>
    <span class="n">x2_sorted</span> <span class="o">=</span> <span class="n">x2_components</span><span class="p">[</span><span class="n">x1_sorted_index</span><span class="p">]</span>

    <span class="n">x1_fit_results</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x1_sorted</span><span class="p">,</span> <span class="n">floc</span><span class="o">=</span><span class="n">mean_location</span><span class="p">)</span>
    <span class="n">x1_fit</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="n">x1_fit_results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="n">x1_fit_results</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="n">x1_fit_results</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="c1"># Step 3: Bin Data &amp; find order 1 linear relation between x1 &amp; x2 means</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">minimum_4_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="mf">0.25</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bin_size</span> <span class="o">&gt;</span> <span class="n">minimum_4_bins</span><span class="p">:</span>
        <span class="n">bin_size</span> <span class="o">=</span> <span class="n">minimum_4_bins</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;To allow for a minimum of 4 bins, the bin size has been &quot;</span>
            <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;set to </span><span class="si">{</span><span class="n">minimum_4_bins</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>

    <span class="n">N_multiples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="n">bin_size</span><span class="p">)</span>
    <span class="n">max_N_multiples_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">N_multiples</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">)</span>

    <span class="n">x1_integer_multiples_of_bin_size</span> <span class="o">=</span> <span class="n">x1_sorted</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">max_N_multiples_index</span><span class="p">]</span>
    <span class="n">x2_integer_multiples_of_bin_size</span> <span class="o">=</span> <span class="n">x2_sorted</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">max_N_multiples_index</span><span class="p">]</span>

    <span class="n">x1_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">x1_integer_multiples_of_bin_size</span><span class="p">,</span> <span class="n">N_multiples</span><span class="p">)</span>
    <span class="n">x2_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">x2_integer_multiples_of_bin_size</span><span class="p">,</span> <span class="n">N_multiples</span><span class="p">)</span>

    <span class="n">x1_last_bin</span> <span class="o">=</span> <span class="n">x1_sorted</span><span class="p">[</span><span class="n">max_N_multiples_index</span><span class="p">:]</span>
    <span class="n">x2_last_bin</span> <span class="o">=</span> <span class="n">x2_sorted</span><span class="p">[</span><span class="n">max_N_multiples_index</span><span class="p">:]</span>

    <span class="n">x1_bins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x1_last_bin</span><span class="p">)</span>
    <span class="n">x2_bins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x2_last_bin</span><span class="p">)</span>

    <span class="n">x1_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">x2_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">x2_sigmas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">for</span> <span class="n">x1_bin</span><span class="p">,</span> <span class="n">x2_bin</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x1_bins</span><span class="p">,</span> <span class="n">x2_bins</span><span class="p">):</span>
        <span class="n">x1_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x1_means</span><span class="p">,</span> <span class="n">x1_bin</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
        <span class="n">x2_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x2_means</span><span class="p">,</span> <span class="n">x2_bin</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
        <span class="n">x2_sigmas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x2_sigmas</span><span class="p">,</span> <span class="n">x2_bin</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>

    <span class="n">mu_fit</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">x1_means</span><span class="p">,</span> <span class="n">x2_means</span><span class="p">)</span>

    <span class="c1"># STEP 4: Find order 2 relation between x1_mean and x2 standard deviation</span>
    <span class="n">sigma_polynomial_order</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">sig_0</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sigma_polynomial_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_objective_function</span><span class="p">(</span><span class="n">sig_p</span><span class="p">,</span> <span class="n">x1_means</span><span class="p">,</span> <span class="n">x2_sigmas</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">sig_p</span><span class="p">,</span> <span class="n">x1_means</span><span class="p">),</span> <span class="n">x2_sigmas</span><span class="p">)</span>

    <span class="c1"># Constraint Functions</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">y_intercept_gt_0</span><span class="p">(</span><span class="n">sig_p</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">sig_polynomial_min_gt_0</span><span class="p">(</span><span class="n">sig_p</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">constraints</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ineq&quot;</span><span class="p">,</span> <span class="s2">&quot;fun&quot;</span><span class="p">:</span> <span class="n">y_intercept_gt_0</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ineq&quot;</span><span class="p">,</span> <span class="s2">&quot;fun&quot;</span><span class="p">:</span> <span class="n">sig_polynomial_min_gt_0</span><span class="p">},</span>
    <span class="p">)</span>

    <span class="n">sigma_fit</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
        <span class="n">_objective_function</span><span class="p">,</span>
        <span class="n">x0</span><span class="o">=</span><span class="n">sig_0</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">x1_means</span><span class="p">,</span> <span class="n">x2_sigmas</span><span class="p">),</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;SLSQP&quot;</span><span class="p">,</span>
        <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">PCA</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;principal_axes&quot;</span><span class="p">:</span> <span class="n">principal_axes</span><span class="p">,</span>
        <span class="s2">&quot;shift&quot;</span><span class="p">:</span> <span class="n">shift</span><span class="p">,</span>
        <span class="s2">&quot;x1_fit&quot;</span><span class="p">:</span> <span class="n">x1_fit</span><span class="p">,</span>
        <span class="s2">&quot;mu_fit&quot;</span><span class="p">:</span> <span class="n">mu_fit</span><span class="p">,</span>
        <span class="s2">&quot;sigma_fit&quot;</span><span class="p">:</span> <span class="n">sigma_fit</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">PCA</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_iso_prob_and_quantile</span><span class="p">(</span><span class="n">sea_state_duration</span><span class="p">,</span> <span class="n">return_period</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the iso-probability and the x, y quantiles along</span>
<span class="sd">    the iso-probability radius</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sea_state_duration : int or float</span>
<span class="sd">        `x1` and `x2` sample rate (seconds)</span>
<span class="sd">    return_period: int, float</span>
<span class="sd">        Return period of interest in years</span>
<span class="sd">    nb_steps: int</span>
<span class="sd">        Discretization of the circle in the normal space.</span>
<span class="sd">        Default nb_steps=1000.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    results: Dictionay</span>
<span class="sd">        Dictionary of the iso-probability results</span>
<span class="sd">        Keys:</span>
<span class="sd">        &#39;exceedance_probability&#39; - probability of exceedance</span>
<span class="sd">        &#39;x_component_iso_prob&#39; - x-component of iso probability circle</span>
<span class="sd">        &#39;y_component_iso_prob&#39; - y-component of iso probability circle</span>
<span class="sd">        &#39;x_quantile&#39; - CDF of x-component</span>
<span class="sd">        &#39;y_quantile&#39; - CDF of y-component</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sea_state_duration</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;sea_state_duration must be of type int or float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sea_state_duration</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_period</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;return_period must be of type int or float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_period</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nb_steps must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">dt_yrs</span> <span class="o">=</span> <span class="n">sea_state_duration</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3600</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">365</span><span class="p">)</span>
    <span class="n">exceedance_probability</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">return_period</span> <span class="o">/</span> <span class="n">dt_yrs</span><span class="p">)</span>
    <span class="n">iso_probability_radius</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span>
        <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">exceedance_probability</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">discretized_radians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">)</span>

    <span class="n">x_component_iso_prob</span> <span class="o">=</span> <span class="n">iso_probability_radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">discretized_radians</span><span class="p">)</span>
    <span class="n">y_component_iso_prob</span> <span class="o">=</span> <span class="n">iso_probability_radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">discretized_radians</span><span class="p">)</span>

    <span class="n">x_quantile</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x_component_iso_prob</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">y_quantile</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">y_component_iso_prob</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;exceedance_probability&quot;</span><span class="p">:</span> <span class="n">exceedance_probability</span><span class="p">,</span>
        <span class="s2">&quot;x_component_iso_prob&quot;</span><span class="p">:</span> <span class="n">x_component_iso_prob</span><span class="p">,</span>
        <span class="s2">&quot;y_component_iso_prob&quot;</span><span class="p">:</span> <span class="n">y_component_iso_prob</span><span class="p">,</span>
        <span class="s2">&quot;x_quantile&quot;</span><span class="p">:</span> <span class="n">x_quantile</span><span class="p">,</span>
        <span class="s2">&quot;y_quantile&quot;</span><span class="p">:</span> <span class="n">y_quantile</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">results</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_copula_parameters</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">min_bin_count</span><span class="p">,</span> <span class="n">initial_bin_max_val</span><span class="p">,</span> <span class="n">bin_val_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an estimate of the Weibull and Lognormal distribution for</span>
<span class="sd">    x1 and x2 respectively. Additionally returns the estimates of the</span>
<span class="sd">    coefficients from the mean and standard deviation of the Log of x2</span>
<span class="sd">    given x1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: array</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: array</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    min_bin_count: int</span>
<span class="sd">        Sets the minimum number of bins allowed</span>
<span class="sd">    initial_bin_max_val: int, float</span>
<span class="sd">        Sets the max value of the first bin</span>
<span class="sd">    bin_val_size: int, float</span>
<span class="sd">        The size of each bin after the initial bin</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    para_dist_1: array</span>
<span class="sd">        Weibull distribution parameters for  for component 1</span>
<span class="sd">    para_dist_2: array</span>
<span class="sd">        Lognormal distribution parameters for component 2</span>
<span class="sd">    mean_cond: array</span>
<span class="sd">        Estimate coefficients of mean of Ln(x2|x1)</span>
<span class="sd">    std_cond: array</span>
<span class="sd">        Estimate coefficients of the standard deviation of Ln(x2|x1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_bin_count</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;min_bin_count must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">min_bin_count</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_val_size</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;bin_val_size must be of type int or float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">bin_val_size</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_bin_max_val</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;initial_bin_max_val must be of type int or float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">initial_bin_max_val</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Binning</span>
    <span class="n">x1_sorted_index</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">x1_sorted</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">x1_sorted_index</span><span class="p">]</span>
    <span class="n">x2_sorted</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="n">x1_sorted_index</span><span class="p">]</span>

    <span class="c1"># Because x1 is sorted we can find the max index as follows:</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">N_vals_lt_limit</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x1_sorted</span> <span class="o">&lt;=</span> <span class="n">initial_bin_max_val</span><span class="p">)</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">N_vals_lt_limit</span><span class="p">)</span>

    <span class="c1"># Make sure first bin isn&#39;t empty or too small to avoid errors</span>
    <span class="k">while</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="n">min_bin_count</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">initial_bin_max_val</span> <span class="o">+=</span> <span class="n">bin_val_size</span>
        <span class="n">N_vals_lt_limit</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x1_sorted</span> <span class="o">&lt;=</span> <span class="n">initial_bin_max_val</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">N_vals_lt_limit</span><span class="p">)</span>

    <span class="c1"># Add bins until the total number of vals in between bins is</span>
    <span class="c1"># &lt; the min bin size</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">bin_size_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">while</span> <span class="n">bin_size_i</span> <span class="o">&gt;=</span> <span class="n">min_bin_count</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">bin_i_max_val</span> <span class="o">=</span> <span class="n">initial_bin_max_val</span> <span class="o">+</span> <span class="n">bin_val_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">N_vals_lt_limit</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x1_sorted</span> <span class="o">&lt;=</span> <span class="n">bin_i_max_val</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">N_vals_lt_limit</span><span class="p">)</span>
        <span class="n">bin_size_i</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Weibull distribution parameters for component 1 using MLE</span>
    <span class="n">para_dist_1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">exponweib</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x1_sorted</span><span class="p">,</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fa</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Lognormal distribution parameters for component 2 using MLE</span>
    <span class="n">para_dist_2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x2_sorted</span><span class="p">))</span>

    <span class="c1"># Parameters for conditional distribution of T|Hs for each bin</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>  <span class="c1"># num+1: number of bins</span>
    <span class="n">para_dist_cond</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hss</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Bin zero special case (lognormal dist over only 1 bin)</span>
    <span class="c1"># parameters for zero bin</span>
    <span class="n">ind0</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">x2_log0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x2_sorted</span><span class="p">[</span><span class="n">ind0</span><span class="p">])</span>
    <span class="n">x2_lognormal_dist0</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x2_log0</span><span class="p">)</span>
    <span class="n">para_dist_cond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x2_lognormal_dist0</span><span class="p">)</span>
    <span class="c1"># mean of x1 (component 1 for zero bin)</span>
    <span class="n">x1_bin0</span> <span class="o">=</span> <span class="n">x1_sorted</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">hss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x1_bin0</span><span class="p">))</span>

    <span class="c1"># Special case 2-bin lognormal Dist</span>
    <span class="c1"># parameters for 1 bin</span>
    <span class="n">ind1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">x2_log1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x2_sorted</span><span class="p">[</span><span class="n">ind1</span><span class="p">])</span>
    <span class="n">x2_lognormal_dist1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x2_log1</span><span class="p">)</span>
    <span class="n">para_dist_cond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x2_lognormal_dist1</span><span class="p">)</span>

    <span class="c1"># mean of Hs (component 1 for bin 1)</span>
    <span class="n">hss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x1_sorted</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]))</span>

    <span class="c1"># lognormal Dist (lognormal dist over only 2 bins)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="n">ind_i</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">x2_log_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x2_sorted</span><span class="p">[</span><span class="n">ind_i</span><span class="p">])</span>
        <span class="n">x2_lognormal_dist_i</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x2_log_i</span><span class="p">)</span>
        <span class="n">para_dist_cond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x2_lognormal_dist_i</span><span class="p">)</span>

        <span class="n">hss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x1_sorted</span><span class="p">[</span><span class="n">ind_i</span><span class="p">]))</span>

    <span class="c1"># Estimate coefficient using least square solution (mean: 3rd order,</span>
    <span class="c1"># sigma: 2nd order)</span>
    <span class="n">ind_f</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)))</span>
    <span class="n">x2_log_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x2_sorted</span><span class="p">[</span><span class="n">ind_f</span><span class="p">])</span>
    <span class="n">x2_lognormal_dist_f</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x2_log_f</span><span class="p">)</span>
    <span class="n">para_dist_cond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x2_lognormal_dist_f</span><span class="p">)</span>  <span class="c1"># parameters for last bin</span>

    <span class="c1"># mean of Hs (component 1 for last bin)</span>
    <span class="n">hss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x1_sorted</span><span class="p">[</span><span class="n">ind_f</span><span class="p">]))</span>

    <span class="n">para_dist_cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">para_dist_cond</span><span class="p">)</span>
    <span class="n">hss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hss</span><span class="p">)</span>

    <span class="c1"># cubic in Hs: a + bx + cx**2 + dx**3</span>
    <span class="n">phi_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">hss</span><span class="p">,</span> <span class="n">hss</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">hss</span><span class="o">**</span><span class="mi">3</span><span class="p">))</span>
    <span class="c1"># quadratic in Hs  a + bx + cx**2</span>
    <span class="n">phi_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">hss</span><span class="p">,</span> <span class="n">hss</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Estimate coefficients of mean of Ln(T|Hs)(vector 4x1) (cubic in Hs)</span>
    <span class="n">mean_cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">phi_mean</span><span class="p">,</span> <span class="n">para_dist_cond</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Estimate coefficients of standard deviation of Ln(T|Hs)</span>
    <span class="c1">#    (vector 3x1) (quadratic in Hs)</span>
    <span class="n">std_cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">phi_std</span><span class="p">,</span> <span class="n">para_dist_cond</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">para_dist_1</span><span class="p">,</span> <span class="n">para_dist_2</span><span class="p">,</span> <span class="n">mean_cond</span><span class="p">,</span> <span class="n">std_cond</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_gaussian_copula</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">component_1</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extreme Sea State Gaussian Copula Contour function.</span>
<span class="sd">    This function calculates environmental contours of extreme sea</span>
<span class="sd">    states using a Gaussian copula and the inverse first-order</span>
<span class="sd">    reliability method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: numpy array</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: numpy array</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    fit: Dictionay</span>
<span class="sd">        Dictionary of the iso-probability results</span>
<span class="sd">    component_1: array</span>
<span class="sd">        Calculated x1 values along the contour boundary following</span>
<span class="sd">        return to original input orientation. component_1 is not</span>
<span class="sd">        specifically used in this calculation but is passed through to</span>
<span class="sd">        create a consistent output from all copula methods.</span>
<span class="sd">    kwargs : optional</span>
<span class="sd">        return_fit: boolean</span>
<span class="sd">              Will return fitting parameters used. Default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    component_1: array</span>
<span class="sd">        Calculated x1 values along the contour boundary following</span>
<span class="sd">        return to original input orientation. component_1 is not</span>
<span class="sd">        specifically used in this calculation but is passed through to</span>
<span class="sd">        create a consistent output from all copula methods.</span>
<span class="sd">    component_2_Gaussian</span>
<span class="sd">        Calculated x2 values along the contour boundary following</span>
<span class="sd">        return to original input orientation.</span>
<span class="sd">    fit: Dictionary (optional)</span>
<span class="sd">        If return_fit=True. Dictionary with iso-probabilities passed</span>
<span class="sd">        with additional fit metrics from the copula method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;component_1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">component_1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="n">return_fit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_fit&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_fit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;If specified, return_fit must be of type bool. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_fit</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">x_component_iso_prob</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;x_component_iso_prob&quot;</span><span class="p">]</span>
    <span class="n">y_component_iso_prob</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;y_component_iso_prob&quot;</span><span class="p">]</span>

    <span class="c1"># Calculate Kendall&#39;s tau</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rho_gau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">tau</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>

    <span class="n">z2_Gauss</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>
        <span class="n">y_component_iso_prob</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rho_gau</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">rho_gau</span> <span class="o">*</span> <span class="n">x_component_iso_prob</span>
    <span class="p">)</span>

    <span class="n">para_dist_2</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;para_dist_2&quot;</span><span class="p">]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">para_dist_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># lognormal inverse</span>
    <span class="n">component_2_Gaussian</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">z2_Gauss</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho_gau</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;z2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z2_Gauss</span>

    <span class="k">if</span> <span class="n">return_fit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">component_1</span><span class="p">,</span> <span class="n">component_2_Gaussian</span><span class="p">,</span> <span class="n">fit</span>
    <span class="k">return</span> <span class="n">component_1</span><span class="p">,</span> <span class="n">component_2_Gaussian</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_gumbel_density</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the Gumbel copula density.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u: np.array</span>
<span class="sd">        Vector of equally spaced points between 0 and twice the</span>
<span class="sd">            maximum value of T.</span>
<span class="sd">    alpha: float</span>
<span class="sd">        Copula parameter. Must be greater than or equal to 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y: np.array</span>
<span class="sd">        Copula density function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ignore divide by 0 warnings and resulting NaN warnings</span>
    <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">vmin</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">vmax</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">nlogC</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">vmin</span> <span class="o">/</span> <span class="n">vmax</span><span class="p">)</span> <span class="o">**</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">nlogC</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
        <span class="o">-</span><span class="n">nlogC</span>
        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nlogC</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;warn&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_gumbel_copula</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">component_1</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates environmental contours of extreme sea</span>
<span class="sd">    states using a Gumbel copula and the inverse first-order reliability</span>
<span class="sd">    method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: numpy array</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: numpy array</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    fit: Dictionay</span>
<span class="sd">        Dictionary of the iso-probability results</span>
<span class="sd">    component_1: array</span>
<span class="sd">        Calculated x1 values along the contour boundary following</span>
<span class="sd">        return to original input orientation. component_1 is not</span>
<span class="sd">        specifically used in this calculation but is passed through to</span>
<span class="sd">        create a consistent output from all copula methods.</span>
<span class="sd">    nb_steps: int</span>
<span class="sd">        Discretization of the circle in the normal space used for</span>
<span class="sd">        copula component calculation.</span>
<span class="sd">    kwargs : optional</span>
<span class="sd">        return_fit: boolean</span>
<span class="sd">              Will return fitting parameters used. Default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    component_1: array</span>
<span class="sd">        Calculated x1 values along the contour boundary following</span>
<span class="sd">        return to original input orientation. component_1 is not</span>
<span class="sd">        specifically used in this calculation but is passed through to</span>
<span class="sd">        create a consistent output from all copula methods.</span>
<span class="sd">    component_2_Gumbel: array</span>
<span class="sd">        Calculated x2 values along the contour boundary following</span>
<span class="sd">        return to original input orientation.</span>
<span class="sd">    fit: Dictionary (optional)</span>
<span class="sd">        If return_fit=True. Dictionary with iso-probabilities passed</span>
<span class="sd">        with additional fit metrics from the copula method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;component_1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">component_1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="n">return_fit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_fit&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_fit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;If specified, return_fit must be of type bool. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_fit</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">x_quantile</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;x_quantile&quot;</span><span class="p">]</span>
    <span class="n">y_quantile</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;y_quantile&quot;</span><span class="p">]</span>
    <span class="n">para_dist_2</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;para_dist_2&quot;</span><span class="p">]</span>

    <span class="c1"># Calculate Kendall&#39;s tau</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">theta_gum</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span>

    <span class="n">min_limit_2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_limit_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">Ndata</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_limit_2</span><span class="p">,</span> <span class="n">max_limit_2</span><span class="p">,</span> <span class="n">Ndata</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">para_dist_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_gum</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;z2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z2</span>

    <span class="n">component_2_Gumbel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">):</span>
        <span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_quantile</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">*</span> <span class="n">Ndata</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">))</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">_gumbel_density</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">theta_gum</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="c1"># pdf 2|1, f(comp_2|comp_1)=c(z1,z2)*f(comp_2)</span>
        <span class="n">p_x_x1</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">*</span> <span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">))</span>
        <span class="c1"># Estimate CDF from PDF</span>
        <span class="n">dum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p_x_x1</span><span class="p">)</span>
        <span class="n">cdf</span> <span class="o">=</span> <span class="n">dum</span> <span class="o">/</span> <span class="p">(</span><span class="n">dum</span><span class="p">[</span><span class="n">Ndata</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Result of conditional CDF derived based on Gumbel copula</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">cdf</span><span class="p">))</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ndata</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">y_quantile</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">component_2_Gumbel</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">table</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">y_quantile</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">component_2_Gumbel</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">table</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">component_2_Gumbel</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">return_fit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">component_1</span><span class="p">,</span> <span class="n">component_2_Gumbel</span><span class="p">,</span> <span class="n">fit</span>
    <span class="k">return</span> <span class="n">component_1</span><span class="p">,</span> <span class="n">component_2_Gumbel</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_clayton_copula</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">component_1</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates environmental contours of extreme sea</span>
<span class="sd">    states using a Clayton copula and the inverse first-order reliability</span>
<span class="sd">    method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: numpy array</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: numpy array</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    fit: Dictionay</span>
<span class="sd">        Dictionary of the iso-probability results</span>
<span class="sd">    component_1: array</span>
<span class="sd">        Calculated x1 values along the contour boundary following</span>
<span class="sd">        return to original input orientation. component_1 is not</span>
<span class="sd">        specifically used in this calculation but is passed through to</span>
<span class="sd">        create a consistent output from all copula methods.</span>
<span class="sd">    nb_steps: int</span>
<span class="sd">        Discretization of the circle in the normal space used for</span>
<span class="sd">        copula component calculation.</span>
<span class="sd">    kwargs : optional</span>
<span class="sd">        return_fit: boolean</span>
<span class="sd">              Will return fitting parameters used. Default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    component_1: array</span>
<span class="sd">        Calculated x1 values along the contour boundary following</span>
<span class="sd">        return to original input orientation. component_1 is not</span>
<span class="sd">        specifically used in this calculation but is passed through to</span>
<span class="sd">        create a consistent output from all copula methods.</span>
<span class="sd">    component_2_Clayton: array</span>
<span class="sd">        Calculated x2 values along the contour boundary following</span>
<span class="sd">        return to original input orientation.</span>
<span class="sd">    fit: Dictionary (optional)</span>
<span class="sd">        If return_fit=True. Dictionary with iso-probabilities passed</span>
<span class="sd">        with additional fit metrics from the copula method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;component_1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">component_1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="n">return_fit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_fit&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_fit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;If specified, return_fit must be of type bool. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_fit</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">x_quantile</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;x_quantile&quot;</span><span class="p">]</span>
    <span class="n">y_quantile</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;y_quantile&quot;</span><span class="p">]</span>
    <span class="n">para_dist_2</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;para_dist_2&quot;</span><span class="p">]</span>

    <span class="c1"># Calculate Kendall&#39;s tau</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">theta_clay</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">tau</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">para_dist_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">z2_Clay</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x_quantile</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">theta_clay</span><span class="p">)</span> <span class="o">+</span> <span class="n">x_quantile</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">theta_clay</span><span class="p">)</span> <span class="o">/</span> <span class="n">y_quantile</span><span class="p">)</span>
        <span class="o">**</span> <span class="p">(</span><span class="n">theta_clay</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">theta_clay</span><span class="p">))</span>
    <span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">theta_clay</span><span class="p">)</span>

    <span class="c1"># lognormal inverse</span>
    <span class="n">component_2_Clayton</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">z2_Clay</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;theta_clay&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_clay</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;z2_Clay&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z2_Clay</span>

    <span class="k">if</span> <span class="n">return_fit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">component_1</span><span class="p">,</span> <span class="n">component_2_Clayton</span><span class="p">,</span> <span class="n">fit</span>
    <span class="k">return</span> <span class="n">component_1</span><span class="p">,</span> <span class="n">component_2_Clayton</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_rosenblatt_copula</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">component_1</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates environmental contours of extreme sea</span>
<span class="sd">    states using a Rosenblatt transformation and the inverse first-order</span>
<span class="sd">    reliability method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: numpy array</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: numpy array</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    fit: Dictionay</span>
<span class="sd">        Dictionary of the iso-probability results</span>
<span class="sd">    component_1: array</span>
<span class="sd">        Calculated x1 values along the contour boundary following</span>
<span class="sd">        return to original input orientation. component_1 is not</span>
<span class="sd">        specifically used in this calculation but is passed through to</span>
<span class="sd">        create a consistent output from all copula methods.</span>
<span class="sd">    nb_steps: int</span>
<span class="sd">        Discretization of the circle in the normal space used for</span>
<span class="sd">        copula component calculation.</span>
<span class="sd">    kwargs : optional</span>
<span class="sd">        return_fit: boolean</span>
<span class="sd">              Will return fitting parameters used. Default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    component_1: array</span>
<span class="sd">        Calculated x1 values along the contour boundary following</span>
<span class="sd">        return to original input orientation. component_1 is not</span>
<span class="sd">        specifically used in this calculation but is passed through to</span>
<span class="sd">        create a consistent output from all copula methods.</span>
<span class="sd">    component_2_Rosenblatt: array</span>
<span class="sd">        Calculated x2 values along the contour boundary following</span>
<span class="sd">        return to original input orientation.</span>
<span class="sd">    fit: Dictionary (optional)</span>
<span class="sd">        If return_fit=True. Dictionary with iso-probabilities passed</span>
<span class="sd">        with additional fit metrics from the copula method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;component_1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">component_1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="n">return_fit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_fit&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_fit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;If specified, return_fit must be of type bool. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_fit</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">y_quantile</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;y_quantile&quot;</span><span class="p">]</span>
    <span class="n">mean_cond</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;mean_cond&quot;</span><span class="p">]</span>
    <span class="n">std_cond</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;std_cond&quot;</span><span class="p">]</span>

    <span class="c1"># mean of Ln(T) as a function of x1</span>
    <span class="n">lamda_cond</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">mean_cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="o">+</span> <span class="n">mean_cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">component_1</span>
        <span class="o">+</span> <span class="n">mean_cond</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">component_1</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">+</span> <span class="n">mean_cond</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">component_1</span><span class="o">**</span><span class="mi">3</span>
    <span class="p">)</span>
    <span class="c1"># Standard deviation of Ln(x2) as a function of x1</span>
    <span class="n">sigma_cond</span> <span class="o">=</span> <span class="n">std_cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">std_cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">component_1</span> <span class="o">+</span> <span class="n">std_cond</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">component_1</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># lognormal inverse</span>
    <span class="n">component_2_Rosenblatt</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span>
        <span class="n">y_quantile</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">sigma_cond</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lamda_cond</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;lamda_cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lamda_cond</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;sigma_cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_cond</span>

    <span class="k">if</span> <span class="n">return_fit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">component_1</span><span class="p">,</span> <span class="n">component_2_Rosenblatt</span><span class="p">,</span> <span class="n">fit</span>
    <span class="k">return</span> <span class="n">component_1</span><span class="p">,</span> <span class="n">component_2_Rosenblatt</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_nonparametric_copula_parameters</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">max_x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_x2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nb_steps</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates nonparametric copula parameters</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: array</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: array</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    max_x1: float</span>
<span class="sd">        Defines the max value of x1 to discretize the KDE space</span>
<span class="sd">    max_x2:float</span>
<span class="sd">        Defines the max value of x2 to discretize the KDE space</span>
<span class="sd">    nb_steps: int</span>
<span class="sd">        number of points used to discretize KDE space</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nonpara_dist_1:</span>
<span class="sd">        x1 points in KDE space and Nonparametric CDF for x1</span>
<span class="sd">    nonpara_dist_2:</span>
<span class="sd">        x2 points in KDE space and Nonparametric CDF for x2</span>
<span class="sd">    nonpara_pdf_2:</span>
<span class="sd">        x2 points in KDE space and Nonparametric PDF for x2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">max_x1</span><span class="p">:</span>
        <span class="n">max_x1</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">max_x2</span><span class="p">:</span>
        <span class="n">max_x2</span> <span class="o">=</span> <span class="n">x2</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_x1</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_x1 must be of type float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">max_x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_x2</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_x2 must be of type float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">max_x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nb_steps must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Binning</span>
    <span class="n">x1_sorted_index</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">x1_sorted</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">x1_sorted_index</span><span class="p">]</span>
    <span class="n">x2_sorted</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="n">x1_sorted_index</span><span class="p">]</span>

    <span class="c1"># Calcualte KDE bounds (potential input)</span>
    <span class="n">min_limit_1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">min_limit_2</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Discretize for KDE</span>
    <span class="n">pts_x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_limit_1</span><span class="p">,</span> <span class="n">max_x1</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">)</span>
    <span class="n">pts_x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_limit_2</span><span class="p">,</span> <span class="n">max_x2</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">)</span>

    <span class="c1"># Calculate optimal bandwidth for T and Hs</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">median_abs_deviation</span><span class="p">(</span><span class="n">x2_sorted</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x2_sorted</span><span class="p">))</span>
    <span class="n">bwT</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">*</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">num</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">)</span>

    <span class="n">sig</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">median_abs_deviation</span><span class="p">(</span><span class="n">x1_sorted</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1_sorted</span><span class="p">))</span>
    <span class="n">bwHs</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">*</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">num</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">)</span>

    <span class="c1"># Nonparametric PDF for x2</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">KDEUnivariate</span><span class="p">(</span><span class="n">x2_sorted</span><span class="p">)</span>
    <span class="n">temp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">bw</span><span class="o">=</span><span class="n">bwT</span><span class="p">)</span>
    <span class="n">f_x2</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">pts_x2</span><span class="p">)</span>

    <span class="c1"># Nonparametric CDF for x1</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">KDEUnivariate</span><span class="p">(</span><span class="n">x1_sorted</span><span class="p">)</span>
    <span class="n">temp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">bw</span><span class="o">=</span><span class="n">bwHs</span><span class="p">)</span>
    <span class="n">tempPDF</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">pts_x1</span><span class="p">)</span>
    <span class="n">F_x1</span> <span class="o">=</span> <span class="n">tempPDF</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tempPDF</span><span class="p">)</span>
    <span class="n">F_x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">F_x1</span><span class="p">)</span>

    <span class="c1"># Nonparametric CDF for x2</span>
    <span class="n">F_x2</span> <span class="o">=</span> <span class="n">f_x2</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f_x2</span><span class="p">)</span>
    <span class="n">F_x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">F_x2</span><span class="p">)</span>

    <span class="n">nonpara_dist_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pts_x1</span><span class="p">,</span> <span class="n">F_x1</span><span class="p">]))</span>
    <span class="n">nonpara_dist_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pts_x2</span><span class="p">,</span> <span class="n">F_x2</span><span class="p">]))</span>
    <span class="n">nonpara_pdf_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pts_x2</span><span class="p">,</span> <span class="n">f_x2</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">nonpara_dist_1</span><span class="p">,</span> <span class="n">nonpara_dist_2</span><span class="p">,</span> <span class="n">nonpara_pdf_2</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_nonparametric_component</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">nonpara_dist</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generalized method for calculating copula components</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z: array</span>
<span class="sd">        CDF of isoprobability</span>
<span class="sd">    nonpara_dist: array</span>
<span class="sd">        x1 or x2 points in KDE space and Nonparametric CDF for x1 or x2</span>
<span class="sd">    nb_steps: int</span>
<span class="sd">        Discretization of the circle in the normal space used for</span>
<span class="sd">        copula component calculation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    component: array</span>
<span class="sd">        nonparametic component values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nb_steps must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">nonpara_dist</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nonpara_dist</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">component</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nonpara_dist</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nonpara_dist</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">component</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nonpara_dist</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nonpara_dist</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">component</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nonpara_dist</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">component</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_nonparametric_gaussian_copula</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates environmental contours of extreme sea</span>
<span class="sd">    states using a Gaussian copula with non-parametric marginal</span>
<span class="sd">    distribution fits and the inverse first-order reliability method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: array</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: array</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    fit: Dictionary</span>
<span class="sd">        Dictionary of the iso-probability results</span>
<span class="sd">    nb_steps: int</span>
<span class="sd">        Discretization of the circle in the normal space used for</span>
<span class="sd">        copula component calculation.</span>
<span class="sd">    kwargs : optional</span>
<span class="sd">        return_fit: boolean</span>
<span class="sd">              Will return fitting parameters used. Default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    component_1_np: array</span>
<span class="sd">        Component 1 nonparametric copula</span>
<span class="sd">    component_2_np_gaussian: array</span>
<span class="sd">        Component 2 nonparametric Gaussian copula</span>
<span class="sd">    fit: Dictionary (optional)</span>
<span class="sd">        If return_fit=True. Dictionary with iso-probabilities passed</span>
<span class="sd">        with additional fit metrics from the copula method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nb_steps must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">return_fit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_fit&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_fit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;If specified, return_fit must be of type bool. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_fit</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">x_component_iso_prob</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;x_component_iso_prob&quot;</span><span class="p">]</span>
    <span class="n">y_component_iso_prob</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;y_component_iso_prob&quot;</span><span class="p">]</span>
    <span class="n">nonpara_dist_1</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;nonpara_dist_1&quot;</span><span class="p">]</span>
    <span class="n">nonpara_dist_2</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;nonpara_dist_2&quot;</span><span class="p">]</span>

    <span class="c1"># Calculate Kendall&#39;s tau</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rho_gau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">tau</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>

    <span class="c1"># Component 1</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x_component_iso_prob</span><span class="p">)</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>
        <span class="n">y_component_iso_prob</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rho_gau</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">rho_gau</span> <span class="o">*</span> <span class="n">x_component_iso_prob</span>
    <span class="p">)</span>

    <span class="n">comps</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">z1</span><span class="p">,</span> <span class="s2">&quot;nonpara_dist&quot;</span><span class="p">:</span> <span class="n">nonpara_dist_1</span><span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">z2</span><span class="p">,</span> <span class="s2">&quot;nonpara_dist&quot;</span><span class="p">:</span> <span class="n">nonpara_dist_2</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">comps</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">]</span>
        <span class="n">nonpara_dist</span> <span class="o">=</span> <span class="n">comps</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s2">&quot;nonpara_dist&quot;</span><span class="p">]</span>
        <span class="n">comps</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s2">&quot;comp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nonparametric_component</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">nonpara_dist</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">)</span>

    <span class="n">component_1_np</span> <span class="o">=</span> <span class="n">comps</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;comp&quot;</span><span class="p">]</span>
    <span class="n">component_2_np_gaussian</span> <span class="o">=</span> <span class="n">comps</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;comp&quot;</span><span class="p">]</span>

    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho_gau</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;z1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z1</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;z2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z2</span>

    <span class="k">if</span> <span class="n">return_fit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">component_1_np</span><span class="p">,</span> <span class="n">component_2_np_gaussian</span><span class="p">,</span> <span class="n">fit</span>
    <span class="k">return</span> <span class="n">component_1_np</span><span class="p">,</span> <span class="n">component_2_np_gaussian</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_nonparametric_clayton_copula</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates environmental contours of extreme sea</span>
<span class="sd">    states using a Clayton copula with non-parametric marginal</span>
<span class="sd">    distribution fits and the inverse first-order reliability method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: array</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: array</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    fit: Dictionary</span>
<span class="sd">        Dictionary of the iso-probability results</span>
<span class="sd">    nb_steps: int</span>
<span class="sd">        Discretization of the circle in the normal space used for</span>
<span class="sd">        copula component calculation.</span>
<span class="sd">    kwargs : optional</span>
<span class="sd">        return_fit: boolean</span>
<span class="sd">              Will return fitting parameters used. Default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    component_1_np: array</span>
<span class="sd">        Component 1 nonparametric copula</span>
<span class="sd">    component_2_np_gaussian: array</span>
<span class="sd">        Component 2 nonparametric Clayton copula</span>
<span class="sd">    fit: Dictionary (optional)</span>
<span class="sd">        If return_fit=True. Dictionary with iso-probabilities passed</span>
<span class="sd">        with additional fit metrics from the copula method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nb_steps must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">return_fit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_fit&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_fit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;If specified, return_fit must be of type bool. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_fit</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">x_component_iso_prob</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;x_component_iso_prob&quot;</span><span class="p">]</span>
    <span class="n">x_quantile</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;x_quantile&quot;</span><span class="p">]</span>
    <span class="n">y_quantile</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;y_quantile&quot;</span><span class="p">]</span>
    <span class="n">nonpara_dist_1</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;nonpara_dist_1&quot;</span><span class="p">]</span>
    <span class="n">nonpara_dist_2</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;nonpara_dist_2&quot;</span><span class="p">]</span>
    <span class="n">nonpara_pdf_2</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;nonpara_pdf_2&quot;</span><span class="p">]</span>

    <span class="c1"># Calculate Kendall&#39;s tau</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">theta_clay</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">tau</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span>

    <span class="c1"># Component 1 (Hs)</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x_component_iso_prob</span><span class="p">)</span>
    <span class="n">z2_clay</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x_quantile</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">theta_clay</span><span class="p">)</span> <span class="o">+</span> <span class="n">x_quantile</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">theta_clay</span><span class="p">)</span> <span class="o">/</span> <span class="n">y_quantile</span><span class="p">)</span>
        <span class="o">**</span> <span class="p">(</span><span class="n">theta_clay</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">theta_clay</span><span class="p">))</span>
    <span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">theta_clay</span><span class="p">)</span>

    <span class="n">comps</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">z1</span><span class="p">,</span> <span class="s2">&quot;nonpara_dist&quot;</span><span class="p">:</span> <span class="n">nonpara_dist_1</span><span class="p">},</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">z2_clay</span><span class="p">,</span> <span class="s2">&quot;nonpara_dist&quot;</span><span class="p">:</span> <span class="n">nonpara_dist_2</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">comps</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">]</span>
        <span class="n">nonpara_dist</span> <span class="o">=</span> <span class="n">comps</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s2">&quot;nonpara_dist&quot;</span><span class="p">]</span>
        <span class="n">comps</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s2">&quot;comp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nonparametric_component</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">nonpara_dist</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">)</span>

    <span class="n">component_1_np</span> <span class="o">=</span> <span class="n">comps</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;comp&quot;</span><span class="p">]</span>
    <span class="n">component_2_np_clayton</span> <span class="o">=</span> <span class="n">comps</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;comp&quot;</span><span class="p">]</span>

    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_clay</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;z1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z1</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;z2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z2_clay</span>

    <span class="k">if</span> <span class="n">return_fit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">component_1_np</span><span class="p">,</span> <span class="n">component_2_np_clayton</span><span class="p">,</span> <span class="n">fit</span>
    <span class="k">return</span> <span class="n">component_1_np</span><span class="p">,</span> <span class="n">component_2_np_clayton</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_nonparametric_gumbel_copula</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates environmental contours of extreme sea</span>
<span class="sd">    states using a Gumbel copula with non-parametric marginal</span>
<span class="sd">    distribution fits and the inverse first-order reliability method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: array</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: array</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    results: Dictionay</span>
<span class="sd">        Dictionary of the iso-probability results</span>
<span class="sd">    nb_steps: int</span>
<span class="sd">        Discretization of the circle in the normal space used for</span>
<span class="sd">        copula component calculation.</span>
<span class="sd">    kwargs : optional</span>
<span class="sd">        return_fit: boolean</span>
<span class="sd">              Will return fitting parameters used. Default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    component_1_np: array</span>
<span class="sd">        Component 1 nonparametric copula</span>
<span class="sd">    component_2_np_gumbel: array</span>
<span class="sd">        Component 2 nonparametric Gumbel copula</span>
<span class="sd">    fit: Dictionary (optional)</span>
<span class="sd">        If return_fit=True. Dictionary with iso-probabilities passed</span>
<span class="sd">        with additional fit metrics from the copula method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nb_steps must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">return_fit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_fit&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_fit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;If specified, return_fit must be a bool. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_fit</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">Ndata</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="n">x_quantile</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;x_quantile&quot;</span><span class="p">]</span>
    <span class="n">y_quantile</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;y_quantile&quot;</span><span class="p">]</span>
    <span class="n">nonpara_dist_1</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;nonpara_dist_1&quot;</span><span class="p">]</span>
    <span class="n">nonpara_dist_2</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;nonpara_dist_2&quot;</span><span class="p">]</span>
    <span class="n">nonpara_pdf_2</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;nonpara_pdf_2&quot;</span><span class="p">]</span>

    <span class="c1"># Calculate Kendall&#39;s tau</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">theta_gum</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span>

    <span class="c1"># Component 1 (Hs)</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="n">x_quantile</span>
    <span class="n">component_1_np</span> <span class="o">=</span> <span class="n">_nonparametric_component</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span> <span class="n">nonpara_dist_1</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">)</span>

    <span class="n">pts_x2</span> <span class="o">=</span> <span class="n">nonpara_pdf_2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">f_x2</span> <span class="o">=</span> <span class="n">nonpara_pdf_2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">F_x2</span> <span class="o">=</span> <span class="n">nonpara_dist_2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">component_2_np_gumbel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">):</span>
        <span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_quantile</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">*</span> <span class="n">Ndata</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">z1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">F_x2</span><span class="p">))</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">_gumbel_density</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">theta_gum</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="c1"># pdf 2|1</span>
        <span class="n">p_x2_x1</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">*</span> <span class="n">f_x2</span>
        <span class="c1"># Estimate CDF from PDF</span>
        <span class="n">dum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p_x2_x1</span><span class="p">)</span>
        <span class="n">cdf</span> <span class="o">=</span> <span class="n">dum</span> <span class="o">/</span> <span class="p">(</span><span class="n">dum</span><span class="p">[</span><span class="n">Ndata</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">pts_x2</span><span class="p">,</span> <span class="n">cdf</span><span class="p">))</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ndata</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">y_quantile</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">component_2_np_gumbel</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">table</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">y_quantile</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">component_2_np_gumbel</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">table</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">component_2_np_gumbel</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">table</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_gum</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;z1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z1</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;pts_x2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts_x2</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;f_x2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_x2</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;F_x2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">F_x2</span>

    <span class="k">if</span> <span class="n">return_fit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">component_1_np</span><span class="p">,</span> <span class="n">component_2_np_gumbel</span><span class="p">,</span> <span class="n">fit</span>
    <span class="k">return</span> <span class="n">component_1_np</span><span class="p">,</span> <span class="n">component_2_np_gumbel</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_bivariate_KDE</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">bw</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">nb_steps</span><span class="p">,</span> <span class="n">Ndata_bivariate_KDE</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Contours generated under this class will use a non-parametric KDE to</span>
<span class="sd">    fit the joint distribution. This function calculates environmental</span>
<span class="sd">    contours of extreme sea states using a bivariate KDE to estimate</span>
<span class="sd">    the joint distribution. The contour is then calculated directly</span>
<span class="sd">    from the joint distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: array</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: array</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    bw: np.array</span>
<span class="sd">        Array containing KDE bandwidth for x1 and x2</span>
<span class="sd">    fit: Dictionay</span>
<span class="sd">        Dictionary of the iso-probability results</span>
<span class="sd">    nb_steps: int</span>
<span class="sd">        number of points used to discretize KDE space</span>
<span class="sd">    max_x1: float</span>
<span class="sd">        Defines the max value of x1 to discretize the KDE space</span>
<span class="sd">    max_x2: float</span>
<span class="sd">        Defines the max value of x2 to discretize the KDE space</span>
<span class="sd">    kwargs : optional</span>
<span class="sd">        return_fit: boolean</span>
<span class="sd">              Will return fitting parameters used. Default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x1_bivariate_KDE: array</span>
<span class="sd">        Calculated x1 values along the contour boundary following</span>
<span class="sd">        return to original input orientation.</span>
<span class="sd">    x2_bivariate_KDE: array</span>
<span class="sd">        Calculated x2 values along the contour boundary following</span>
<span class="sd">        return to original input orientation.</span>
<span class="sd">    fit: Dictionary (optional)</span>
<span class="sd">        If return_fit=True. Dictionary with iso-probabilities passed</span>
<span class="sd">        with additional fit metrics from the copula method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nb_steps must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">max_x1</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_x1&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">max_x2</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_x2&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">log_transform</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;log_transform&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">return_fit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_fit&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_x1</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)):</span>
        <span class="n">max_x1</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_x2</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)):</span>
        <span class="n">max_x2</span> <span class="o">=</span> <span class="n">x2</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_x1</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_x1 must be of type float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">max_x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_x2</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_x2 must be of type float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">max_x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">log_transform</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;If specified, log_transform must be of type bool. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">log_transform</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_fit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;If specified, return_fit must be of type bool. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_fit</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">p_f</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;exceedance_probability&quot;</span><span class="p">]</span>

    <span class="n">min_limit_1</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="n">min_limit_2</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="n">pts_x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_limit_1</span><span class="p">,</span> <span class="n">max_x1</span><span class="p">,</span> <span class="n">Ndata_bivariate_KDE</span><span class="p">)</span>
    <span class="n">pts_x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_limit_2</span><span class="p">,</span> <span class="n">max_x2</span><span class="p">,</span> <span class="n">Ndata_bivariate_KDE</span><span class="p">)</span>
    <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">pts_x2</span><span class="p">,</span> <span class="n">pts_x1</span><span class="p">)</span>
    <span class="n">mesh_pts_x2</span> <span class="o">=</span> <span class="n">pt1</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">mesh_pts_x1</span> <span class="o">=</span> <span class="n">pt2</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Transform gridded points using log</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">[</span><span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">]</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_pts_x2</span><span class="p">,</span> <span class="n">mesh_pts_x1</span><span class="p">]</span>
    <span class="n">txi</span> <span class="o">=</span> <span class="n">xi</span>
    <span class="k">if</span> <span class="n">log_transform</span><span class="p">:</span>
        <span class="n">ty</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x1</span><span class="p">)]</span>
        <span class="n">txi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mesh_pts_x2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mesh_pts_x1</span><span class="p">)]</span>

    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">txi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ty</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1"># Create contour</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">ftemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">txi</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ty</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="n">bw</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">fk</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">log_transform</span><span class="p">:</span>
                <span class="n">fnew</span> <span class="o">=</span> <span class="n">fk</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fnew</span> <span class="o">=</span> <span class="n">fk</span>
            <span class="n">fnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fnew</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">ftemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">ftemp</span><span class="p">,</span> <span class="n">fnew</span><span class="p">)</span>
        <span class="n">f</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">ftemp</span><span class="p">)</span>

    <span class="n">fhat</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">fhat</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="n">p_f</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
    <span class="n">x1_bivariate_KDE</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">x2_bivariate_KDE</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">vertices</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">vals</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()]</span>

    <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
        <span class="n">x1_bivariate_KDE</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">x2_bivariate_KDE</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">x1_bivariate_KDE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x1_bivariate_KDE</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">x2_bivariate_KDE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x2_bivariate_KDE</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;mesh_pts_x1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh_pts_x1</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;mesh_pts_x2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh_pts_x2</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;ty&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ty</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;xi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xi</span>
    <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;contour_vals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>

    <span class="k">if</span> <span class="n">return_fit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x1_bivariate_KDE</span><span class="p">,</span> <span class="n">x2_bivariate_KDE</span><span class="p">,</span> <span class="n">fit</span>
    <span class="k">return</span> <span class="n">x1_bivariate_KDE</span><span class="p">,</span> <span class="n">x2_bivariate_KDE</span>


<span class="c1"># Sampling</span>
<div class="viewcode-block" id="samples_full_seastate">
<a class="viewcode-back" href="../../../mhkit-python/api.wave.html#mhkit.wave.contours.samples_full_seastate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">samples_full_seastate</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">,</span>
    <span class="n">points_per_interval</span><span class="p">,</span>
    <span class="n">return_periods</span><span class="p">,</span>
    <span class="n">sea_state_duration</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;PCA&quot;</span><span class="p">,</span>
    <span class="n">bin_size</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample a sea state between contours of specified return periods.</span>

<span class="sd">    This function is used for the full sea state approach for the</span>
<span class="sd">    extreme load. See Coe et al. 2018 for more details. It was</span>
<span class="sd">    originally part of WDRT.</span>

<span class="sd">    Coe, R. G., Michelen, C., Eckert-Gallup, A., &amp;</span>
<span class="sd">    Sallaberry, C. (2018). Full long-term design response analysis of a</span>
<span class="sd">    wave energy converter. Renewable Energy, 116, 356-366.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1: list, np.ndarray, pd.Series, xr.DataArray</span>
<span class="sd">        Component 1 data</span>
<span class="sd">    x2: list, np.ndarray, pd.Series, xr.DataArray</span>
<span class="sd">        Component 2 data</span>
<span class="sd">    points_per_interval : int</span>
<span class="sd">        Number of sample points to be calculated per contour interval.</span>
<span class="sd">    return_periods: np.array</span>
<span class="sd">        Vector of return periods that define the contour intervals in</span>
<span class="sd">        which samples will be taken. Values must be greater than zero</span>
<span class="sd">        and must be in increasing order.</span>
<span class="sd">    sea_state_duration : int or float</span>
<span class="sd">        `x1` and `x2` sample rate (seconds)</span>
<span class="sd">    method: string or list</span>
<span class="sd">        Copula method to apply. Currently only &#39;PCA&#39; is implemented.</span>
<span class="sd">    bin_size : int</span>
<span class="sd">        Number of data points in each bin</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Hs_Samples: np.array</span>
<span class="sd">        Vector of Hs values for each sample point.</span>
<span class="sd">    Te_Samples: np.array</span>
<span class="sd">        Vector of Te values for each sample point.</span>
<span class="sd">    weight_points: np.array</span>
<span class="sd">        Vector of probabilistic weights for each sampling point</span>
<span class="sd">        to be used in risk calculations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;PCA&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Full sea state sampling is currently only implemented using &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;the &#39;PCA&#39; method.&quot;</span>
        <span class="p">)</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="s2">&quot;x1&quot;</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="s2">&quot;x2&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points_per_interval</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;points_per_interval must be of int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">points_per_interval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_periods</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;return_periods must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">return_periods</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sea_state_duration</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;sea_state_duration must be of int or float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sea_state_duration</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;method must be of type string or list. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">method</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bin_size must be of int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">bin_size</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">pca_fit</span> <span class="o">=</span> <span class="n">_principal_component_analysis</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">)</span>

    <span class="c1"># Calculate line where Hs = 0 to avoid sampling Hs in negative space</span>
    <span class="n">t_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">t_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">t_zeroline</span><span class="p">)</span>
    <span class="n">h_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_zeroline</span><span class="p">))</span>

    <span class="c1"># Transform zero line into principal component space</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="n">pca_fit</span><span class="p">[</span><span class="s2">&quot;principal_axes&quot;</span><span class="p">]</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">pca_fit</span><span class="p">[</span><span class="s2">&quot;shift&quot;</span><span class="p">]</span>
    <span class="n">comp_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">h_zeroline</span><span class="p">,</span> <span class="n">t_zeroline</span><span class="p">])),</span> <span class="n">coeff</span><span class="p">)</span>
    <span class="n">comp_zeroline</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp_zeroline</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span>

    <span class="n">comp1</span> <span class="o">=</span> <span class="n">pca_fit</span><span class="p">[</span><span class="s2">&quot;x1_fit&quot;</span><span class="p">]</span>
    <span class="n">c1_zeroline_prob</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>
        <span class="n">comp_zeroline</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mu</span><span class="o">=</span><span class="n">comp1</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">comp1</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">mu_slope</span> <span class="o">=</span> <span class="n">pca_fit</span><span class="p">[</span><span class="s2">&quot;mu_fit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">slope</span>
    <span class="n">mu_intercept</span> <span class="o">=</span> <span class="n">pca_fit</span><span class="p">[</span><span class="s2">&quot;mu_fit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">intercept</span>
    <span class="n">mu_zeroline</span> <span class="o">=</span> <span class="n">mu_slope</span> <span class="o">*</span> <span class="n">comp_zeroline</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">mu_intercept</span>

    <span class="n">sigma_polynomial_coeffcients</span> <span class="o">=</span> <span class="n">pca_fit</span><span class="p">[</span><span class="s2">&quot;sigma_fit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
    <span class="n">sigma_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">sigma_polynomial_coeffcients</span><span class="p">,</span> <span class="n">comp_zeroline</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">c2_zeroline_prob</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>
        <span class="n">comp_zeroline</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu_zeroline</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma_zeroline</span>
    <span class="p">)</span>

    <span class="n">c1_normzeroline</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">c1_zeroline_prob</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">c2_normzeroline</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">c2_zeroline_prob</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">return_periods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">return_periods</span><span class="p">)</span>
    <span class="n">contour_probs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">/</span> <span class="n">sea_state_duration</span> <span class="o">*</span> <span class="n">return_periods</span><span class="p">)</span>

    <span class="c1"># Reliability contour generation</span>
    <span class="c1"># Calculate reliability</span>
    <span class="n">beta_lines</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">contour_probs</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Add zero as lower bound to first contour</span>
    <span class="n">beta_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta_lines</span><span class="p">))</span>
    <span class="c1"># Discretize the circle</span>
    <span class="n">theta_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="c1"># Add probablity of 1 to the reliability set, corresponding to</span>
    <span class="c1"># probability of the center point of the normal space</span>
    <span class="n">contour_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">contour_probs</span><span class="p">))</span>

    <span class="c1"># Vary U1,U2 along circle sqrt(U1^2+U2^2) = beta</span>
    <span class="n">u1_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_lines</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]),</span> <span class="n">beta_lines</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>

    <span class="c1"># Removing values on the H_s = 0 line that are far from the circles in the</span>
    <span class="c1"># normal space that will be evaluated to speed up calculations</span>
    <span class="n">minval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">u1_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">c1_normzeroline</span> <span class="o">&gt;</span> <span class="n">minval</span>
    <span class="n">c1_normzeroline</span> <span class="o">=</span> <span class="n">c1_normzeroline</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">c2_normzeroline</span> <span class="o">=</span> <span class="n">c2_normzeroline</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

    <span class="c1"># Transform to polar coordinates</span>
    <span class="n">theta_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">c2_normzeroline</span><span class="p">,</span> <span class="n">c1_normzeroline</span><span class="p">)</span>
    <span class="n">rho_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c1_normzeroline</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c2_normzeroline</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">theta_zeroline</span><span class="p">[</span><span class="n">theta_zeroline</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_zeroline</span><span class="p">[</span><span class="n">theta_zeroline</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="n">sample_alpha</span><span class="p">,</span> <span class="n">sample_beta</span><span class="p">,</span> <span class="n">weight_points</span> <span class="o">=</span> <span class="n">_generate_sample_data</span><span class="p">(</span>
        <span class="n">beta_lines</span><span class="p">,</span> <span class="n">rho_zeroline</span><span class="p">,</span> <span class="n">theta_zeroline</span><span class="p">,</span> <span class="n">points_per_interval</span><span class="p">,</span> <span class="n">contour_probs</span>
    <span class="p">)</span>

    <span class="c1"># Sample transformation to principal component space</span>
    <span class="n">sample_u1</span> <span class="o">=</span> <span class="n">sample_beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">sample_alpha</span><span class="p">)</span>
    <span class="n">sample_u2</span> <span class="o">=</span> <span class="n">sample_beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">sample_alpha</span><span class="p">)</span>

    <span class="n">comp1_sample</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span>
        <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">sample_u1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">mu</span><span class="o">=</span><span class="n">comp1</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">],</span>
        <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">comp1</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">mu_sample</span> <span class="o">=</span> <span class="n">mu_slope</span> <span class="o">*</span> <span class="n">comp1_sample</span> <span class="o">+</span> <span class="n">mu_intercept</span>

    <span class="c1"># Calculate sigma values at each point on the circle</span>
    <span class="n">sigma_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">sigma_polynomial_coeffcients</span><span class="p">,</span> <span class="n">comp1_sample</span><span class="p">)</span>

    <span class="c1"># Use calculated mu and sigma values to calculate C2 along the contour</span>
    <span class="n">comp2_sample</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span>
        <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">sample_u2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu_sample</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma_sample</span>
    <span class="p">)</span>

    <span class="c1"># Sample transformation into Hs-T space</span>
    <span class="n">h_sample</span><span class="p">,</span> <span class="n">t_sample</span> <span class="o">=</span> <span class="n">_princomp_inv</span><span class="p">(</span><span class="n">comp1_sample</span><span class="p">,</span> <span class="n">comp2_sample</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">h_sample</span><span class="p">,</span> <span class="n">t_sample</span><span class="p">,</span> <span class="n">weight_points</span></div>



<div class="viewcode-block" id="samples_contour">
<a class="viewcode-back" href="../../../mhkit-python/api.wave.html#mhkit.wave.contours.samples_contour">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">samples_contour</span><span class="p">(</span><span class="n">t_samples</span><span class="p">,</span> <span class="n">t_contour</span><span class="p">,</span> <span class="n">hs_contour</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get Hs points along a specified environmental contour using</span>
<span class="sd">    user-defined T values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t_samples : list, np.ndarray, pd.Series, xr.DataArray</span>
<span class="sd">        Points for sampling along return contour</span>
<span class="sd">    t_contour : list, np.ndarray, pd.Series, xr.DataArray</span>
<span class="sd">        T values along contour</span>
<span class="sd">    hs_contour : list, np.ndarray, pd.Series, xr.DataArray</span>
<span class="sd">        Hs values along contour</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hs_samples : np.ndarray</span>
<span class="sd">        points sampled along return contour</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t_samples</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">t_samples</span><span class="p">,</span> <span class="s2">&quot;t_samples&quot;</span><span class="p">)</span>
    <span class="n">t_contour</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">t_contour</span><span class="p">,</span> <span class="s2">&quot;t_contour&quot;</span><span class="p">)</span>
    <span class="n">hs_contour</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">hs_contour</span><span class="p">,</span> <span class="s2">&quot;hs_contour&quot;</span><span class="p">)</span>

    <span class="c1"># finds minimum and maximum energy period values</span>
    <span class="n">amin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">t_contour</span><span class="p">)</span>
    <span class="n">amax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">t_contour</span><span class="p">)</span>
    <span class="n">aamin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">amin</span><span class="p">,</span> <span class="n">amax</span><span class="p">])</span>
    <span class="n">aamax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">amin</span><span class="p">,</span> <span class="n">amax</span><span class="p">])</span>
    <span class="c1"># finds points along the contour</span>
    <span class="n">w1</span> <span class="o">=</span> <span class="n">hs_contour</span><span class="p">[</span><span class="n">aamin</span><span class="p">:</span><span class="n">aamax</span><span class="p">]</span>
    <span class="n">w2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">hs_contour</span><span class="p">[</span><span class="n">aamax</span><span class="p">:],</span> <span class="n">hs_contour</span><span class="p">[:</span><span class="n">aamin</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">w1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">w2</span><span class="p">):</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">t_contour</span><span class="p">[</span><span class="n">aamin</span><span class="p">:</span><span class="n">aamax</span><span class="p">]</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">hs_contour</span><span class="p">[</span><span class="n">aamin</span><span class="p">:</span><span class="n">aamax</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">t_contour</span><span class="p">[</span><span class="n">aamax</span><span class="p">:],</span> <span class="n">t_contour</span><span class="p">[:</span><span class="n">aamin</span><span class="p">]))</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">hs_contour</span><span class="p">[</span><span class="n">aamax</span><span class="p">:],</span> <span class="n">hs_contour</span><span class="p">[:</span><span class="n">aamin</span><span class="p">]))</span>
    <span class="c1"># sorts data based on the max and min energy period values</span>
    <span class="n">ms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">ms</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">ms</span><span class="p">]</span>
    <span class="c1"># interpolates the sorted data</span>
    <span class="n">si</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="c1"># finds the wave height based on the user specified energy period values</span>
    <span class="n">hs_samples</span> <span class="o">=</span> <span class="n">si</span><span class="p">(</span><span class="n">t_samples</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hs_samples</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_generate_sample_data</span><span class="p">(</span>
    <span class="n">beta_lines</span><span class="p">,</span> <span class="n">rho_zeroline</span><span class="p">,</span> <span class="n">theta_zeroline</span><span class="p">,</span> <span class="n">points_per_interval</span><span class="p">,</span> <span class="n">contour_probs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate radius, angle, and weight for each sample point</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    beta_lines: list, np.ndarray, pd.Series, xr.DataArray</span>
<span class="sd">        Array of mu fitting function parameters.</span>
<span class="sd">    rho_zeroline: list, np.ndarray, pd.Series, xr.DataArray</span>
<span class="sd">        Array of radii</span>
<span class="sd">    theta_zeroline: list, np.ndarray, pd.Series, xr.DataArray</span>
<span class="sd">    points_per_interval: int</span>
<span class="sd">    contour_probs: list, np.ndarray, pd.Series, xr.DataArray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sample_alpha: np.array</span>
<span class="sd">        Array of fitted sample angle values.</span>
<span class="sd">    sample_beta: np.array</span>
<span class="sd">        Array of fitted sample radius values.</span>
<span class="sd">    weight_points: np.array</span>
<span class="sd">        Array of weights for each point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">beta_lines</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">,</span> <span class="s2">&quot;beta_lines&quot;</span><span class="p">)</span>
    <span class="n">rho_zeroline</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">rho_zeroline</span><span class="p">,</span> <span class="s2">&quot;rho_zeroline&quot;</span><span class="p">)</span>
    <span class="n">theta_zeroline</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">theta_zeroline</span><span class="p">,</span> <span class="s2">&quot;theta_zeroline&quot;</span><span class="p">)</span>
    <span class="n">contour_probs</span> <span class="o">=</span> <span class="n">to_numeric_array</span><span class="p">(</span><span class="n">contour_probs</span><span class="p">,</span> <span class="s2">&quot;contour_probs&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points_per_interval</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;points_per_interval must be of type int. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">points_per_interval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">num_samples</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">points_per_interval</span>
    <span class="n">alpha_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">angular_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">angular_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">points_per_interval</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">sample_beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="n">sample_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="n">weight_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>

    <span class="c1"># Loop over contour intervals</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Check if any of the radii for the Hs=0, line are smaller than</span>
        <span class="c1"># the radii of the contour, meaning that these lines intersect</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rho_zeroline</span> <span class="o">-</span> <span class="n">beta_lines</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.01</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
            <span class="c1"># Save sampling bounds</span>
            <span class="n">alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">theta_zeroline</span><span class="p">[</span><span class="n">left</span><span class="p">],</span>
                <span class="n">theta_zeroline</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="c1"># Find the angular distance that will be covered by sampling the disc</span>
        <span class="n">angular_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="c1"># Calculate ratio of area covered for each contour</span>
        <span class="n">angular_ratio</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">angular_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="c1"># Discretize the remaining portion of the disc into 10 equally spaced</span>
        <span class="c1"># areas to be sampled</span>
        <span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="nb">min</span><span class="p">(</span><span class="n">alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">,</span>
            <span class="n">angular_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">points_per_interval</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Calculate the weight of each point sampled per contour</span>
        <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">contour_probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">contour_probs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="o">*</span> <span class="n">angular_ratio</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="o">/</span> <span class="n">points_per_interval</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">points_per_interval</span><span class="p">):</span>
            <span class="c1"># Generate sample radius by adding a randomly sampled distance to</span>
            <span class="c1"># the &#39;disc&#39; lower bound</span>
            <span class="n">sample_beta</span><span class="p">[(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">points_per_interval</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta_lines</span><span class="p">[</span>
                <span class="n">i</span>
            <span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">beta_lines</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">beta_lines</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># Generate sample angle by adding a randomly sampled distance to</span>
            <span class="c1"># the lower bound of the angle defining a discrete portion of the</span>
            <span class="c1"># &#39;disc&#39;</span>
            <span class="n">sample_alpha</span><span class="p">[(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">points_per_interval</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span>
            <span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="c1"># Save the weight for each sample point</span>
            <span class="n">weight_points</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">points_per_interval</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">sample_alpha</span><span class="p">,</span> <span class="n">sample_beta</span><span class="p">,</span> <span class="n">weight_points</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_princomp_inv</span><span class="p">(</span><span class="n">princip_data1</span><span class="p">,</span> <span class="n">princip_data2</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take the inverse of the principal component rotation given data,</span>
<span class="sd">    coefficients, and shift.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    princip_data1: np.array</span>
<span class="sd">        Array of Component 1 values.</span>
<span class="sd">    princip_data2: np.array</span>
<span class="sd">        Array of Component 2 values.</span>
<span class="sd">    coeff: np.array</span>
<span class="sd">        Array of principal component coefficients.</span>
<span class="sd">    shift: float</span>
<span class="sd">        Shift applied to Component 2 to make all values positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    original1: np.array</span>
<span class="sd">        Hs values following rotation from principal component space.</span>
<span class="sd">    original2: np.array</span>
<span class="sd">        T values following rotation from principal component space.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">princip_data1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;princip_data1 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">princip_data1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">princip_data2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;princip_data2 must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">princip_data2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;coeff must be of type np.ndarray. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shift must be of type float. Got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">original1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">princip_data1</span><span class="p">))</span>
    <span class="n">original2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">princip_data1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">princip_data2</span><span class="p">)):</span>
        <span class="n">original1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">princip_data2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">princip_data1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">original2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">princip_data1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="o">-</span> <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">princip_data2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span>
        <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">original1</span><span class="p">,</span> <span class="n">original2</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, National Renewable Energy Laboratory, Pacific Northwest National Laboratory, and Sandia National Laboratories.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>